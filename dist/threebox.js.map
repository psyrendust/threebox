{"version":3,"file":"threebox.js","sources":["webpack:///webpack/bootstrap 331fbbdb3a6ef261bb21","webpack:///src/three.js","webpack:///src/constants.js","webpack:///src/Threebox.js","webpack:///src/Camera/CameraSync.js","webpack:///src/Layers/SymbolLayer3D.js","webpack:///src/Utils/valueGenerator.js","webpack:///src/utils/RAF.js","webpack:///./src/threebox.scss","webpack:///src/utils/index.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 331fbbdb3a6ef261bb21","const THREE = window.THREE;\nexport default THREE;\n\n\n\n// WEBPACK FOOTER //\n// src/three.js","const WORLD_SIZE = 512;\nconst MERCATOR_A = 6378137.0;\n\nmodule.exports = {\n  WORLD_SIZE,\n  PROJECTION_WORLD_SIZE: WORLD_SIZE / (MERCATOR_A * Math.PI) / 2,\n  MERCATOR_A, // 900913 projection property\n  DEG2RAD: Math.PI / 180,\n  RAD2DEG: 180 / Math.PI,\n  EARTH_CIRCUMFERENCE: 40075000, // In meters\n};\n\n\n\n// WEBPACK FOOTER //\n// src/constants.js","import THREE from './three';\nimport ThreeboxConstants from './constants';\nimport CameraSync from './Camera/CameraSync';\nimport SymbolLayer3D from './Layers/SymbolLayer3D';\nimport RAF from './utils/RAF';\n\nrequire('./threebox.scss');\n\nfunction Threebox(map) {\n  this.map = map;\n\n    // Set up a THREE.js scene\n  this.renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});\n  this.renderer.setSize(this.map.transform.width, this.map.transform.height);\n  this.renderer.shadowMap.enabled = true;\n\n  this.map._container.appendChild(this.renderer.domElement);\n  this.renderer.domElement.classList.add('threebox-canvas');\n    // this.renderer.domElement.style[\"transform\"] = \"scale(1,-1)\";\n\n  const _this = this;\n  this.map.on('resize', () => { _this.renderer.setSize(_this.map.transform.width, _this.map.transform.height); });\n\n\n  this.scene = new THREE.Scene();\n  this.camera = new THREE.PerspectiveCamera(28, window.innerWidth / window.innerHeight, 0.000001, 5000000000);\n  this.layers = [];\n  this.mouse = new THREE.Vector2();\n  this.raycaster = new THREE.Raycaster();\n\n    // The CameraSync object will keep the Mapbox and THREE.js camera movements in sync.\n    // It requires a world group to scale as we zoom in. Rotation is handled in the camera's\n    // projection matrix itself (as is field of view and near/far clipping)\n    // It automatically registers to listen for move events on the map so we don't need to do that here\n  this.world = new THREE.Group();\n  this.scene.add(this.world);\n  this.cameraSynchronizer = new CameraSync(this.map, this.camera, this.world);\n\n  this.raf = new RAF(this.renderer, this.scene, this.camera);\n  this.raf.start();\n}\n\nThreebox.prototype = {\n  SymbolLayer3D,\n\n  start() {\n    this.raf.start();\n  },\n  step() {\n    this.raf.step();\n  },\n  stop() {\n    this.raf.stop();\n  },\n  onUpdate(fn, scope) {\n    this.raf.onUpdate(fn, scope);\n  },\n  onAfterUpdate(fn, scope) {\n    this.raf.onAfterUpdate(fn, scope);\n  },\n  onRender(fn, scope) {\n    this.raf.onUpdate(fn, scope);\n  },\n  onAfterRender(fn, scope) {\n    this.raf.onAfterUpdate(fn, scope);\n  },\n\n  getMousePositionFromMapPoint(point) {\n    this.mouse.x = (point.x / this.map.transform.width) * 2 - 1;\n    this.mouse.y = -((point.y) / this.map.transform.height) * 2 + 1;\n    return this.mouse.clone();\n  },\n\n  getIntersects(point, recursive, objects) {\n    this.raycaster.setFromCamera(point, this.camera);\n    return this.raycaster.intersectObjects(objects || this.world.children, recursive);\n  },\n\n  getIntersectsFromMapPoint(point, recursive, objects) {\n    return this.getIntersects(this.getMousePositionFromMapPoint(point), recursive, objects);\n  },\n\n  projectToWorld(coords) {\n        // Spherical mercator forward projection, re-scaling to WORLD_SIZE\n    const projected = [\n      -ThreeboxConstants.MERCATOR_A * coords[0] * ThreeboxConstants.DEG2RAD * ThreeboxConstants.PROJECTION_WORLD_SIZE,\n      -ThreeboxConstants.MERCATOR_A * Math.log(Math.tan((Math.PI * 0.25) + (0.5 * coords[1] * ThreeboxConstants.DEG2RAD))) * ThreeboxConstants.PROJECTION_WORLD_SIZE, // eslint-disable-line\n    ];\n\n    const pixelsPerMeter = this.projectedUnitsPerMeter(coords[1]);\n\n        // z dimension\n    const height = coords[2] || 0;\n    projected.push(height * pixelsPerMeter);\n\n    const result = new THREE.Vector3(projected[0], projected[1], projected[2]);\n\n    return result;\n  },\n  projectedUnitsPerMeter(latitude) {\n    return Math.abs(ThreeboxConstants.WORLD_SIZE * (1 / Math.cos(latitude * Math.PI / 180)) / ThreeboxConstants.EARTH_CIRCUMFERENCE);\n  },\n  _scaleVerticesToMeters(centerLatLng, vertices) {\n    const pixelsPerMeter = this.projectedUnitsPerMeter(centerLatLng[1]);\n    // const centerProjected = this.projectToWorld(centerLatLng);\n\n    for (let i = 0; i < vertices.length; i += 1) {\n      vertices[i].multiplyScalar(pixelsPerMeter);\n    }\n\n    return vertices;\n  },\n  projectToScreen(coords) {\n    console.log('WARNING: Projecting to screen coordinates is not yet implemented'); // eslint-disable-line\n  },\n  unprojectFromScreen(pixel) {\n    console.log('WARNING: unproject is not yet implemented'); // eslint-disable-line\n  },\n  unprojectFromWorld(pixel) {\n    const unprojected = [\n      -pixel.x / (ThreeboxConstants.MERCATOR_A * ThreeboxConstants.DEG2RAD * ThreeboxConstants.PROJECTION_WORLD_SIZE),\n      2 * (Math.atan(Math.exp(pixel.y / (ThreeboxConstants.PROJECTION_WORLD_SIZE * (-ThreeboxConstants.MERCATOR_A)))) - Math.PI / 4) / ThreeboxConstants.DEG2RAD, // eslint-disable-line\n    ];\n\n    const pixelsPerMeter = this.projectedUnitsPerMeter(unprojected[1]);\n\n        // z dimension\n    const height = pixel.z || 0;\n    unprojected.push(height / pixelsPerMeter);\n\n    return unprojected;\n  },\n\n  _flipMaterialSides(obj) {\n\n  },\n\n  addAtCoordinate(obj, lnglat, options) {\n    const geoGroup = new THREE.Group();\n    geoGroup.userData.isGeoGroup = true;\n    geoGroup.add(obj);\n    this._flipMaterialSides(obj);\n    this.world.add(geoGroup);\n    this.moveToCoordinate(obj, lnglat, options);\n\n        // Bestow this mesh with animation superpowers and keeps track of its movements in the global animation queue\n        // this.animationManager.enroll(obj);\n\n    return obj;\n  },\n  moveToCoordinate(obj, lnglat, options) {\n        /** Place the given object on the map, centered around the provided longitude and latitude\n            The object's internal coordinates are assumed to be in meter-offset format, meaning\n            1 unit represents 1 meter distance away from the provided coordinate.\n        */\n\n    if (options === undefined) options = {};\n    if (options.preScale === undefined) options.preScale = 1.0;\n    if (options.scaleToLatitude === undefined || obj.userData.scaleToLatitude) options.scaleToLatitude = true;\n\n    obj.userData.scaleToLatitude = options.scaleToLatitude;\n\n    if (typeof options.preScale === 'number') options.preScale = new THREE.Vector3(options.preScale, options.preScale, options.preScale);\n    else if (options.preScale.constructor === Array && options.preScale.length === 3) options.preScale = new THREE.Vector3(options.preScale[0], options.preScale[1], options.preScale[2]); // eslint-disable-line\n    else if (options.preScale.constructor !== THREE.Vector3) {\n      console.warn('Invalid preScale value: number, Array with length 3, or THREE.Vector3 expected. Defaulting to [1,1,1]'); // eslint-disable-line\n      options.preScale = new THREE.Vector3(1, 1, 1);\n    }\n\n    const scale = options.preScale;\n\n        // Figure out if this object is a geoGroup and should be positioned and scaled directly, or if its parent\n    let geoGroup;\n    if (obj.userData.isGeoGroup) geoGroup = obj;\n    else if (obj.parent && obj.parent.userData.isGeoGroup) geoGroup = obj.parent;\n    else return console.error(\"Cannot set geographic coordinates of object that does not have an associated GeoGroup. Object must be added to scene with 'addAtCoordinate()'.\"); // eslint-disable-line\n\n    if (options.scaleToLatitude) {\n            // Scale the model so that its units are interpreted as meters at the given latitude\n      const pixelsPerMeter = this.projectedUnitsPerMeter(lnglat[1]);\n      scale.multiplyScalar(pixelsPerMeter);\n    }\n\n    geoGroup.scale.copy(scale);\n\n    geoGroup.position.copy(this.projectToWorld(lnglat));\n    obj.coordinates = lnglat;\n\n    return obj;\n  },\n\n  addGeoreferencedMesh(mesh, options) {\n        /* Place the mesh on the map, assuming its internal (x,y) coordinates are already in (longitude, latitude) format\n            TODO: write this\n        */\n\n  },\n\n  addSymbolLayer(options) {\n    const layer = new SymbolLayer3D(this, options);\n    this.layers.push(layer);\n\n    return layer;\n  },\n\n  getDataLayer(id) {\n    for (let i = 0; i < this.layers.length; i += 1) {\n      const layer = this.layers[i];\n      if (layer.id === id) {\n        return layer;\n      }\n    }\n    return null;\n  },\n\n  add(obj) {\n    this.world.add(obj);\n  },\n\n  remove(obj) {\n    this.world.remove(obj);\n  },\n\n  setupDefaultLights() {\n    this.scene.add(new THREE.AmbientLight(0x404040));\n\n    // Taken from https://threejs.org/examples/webgl_lights_hemisphere.html\n    // LIGHTS\n    // HemisphereLight does not cast shadows\n    const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);\n    hemiLight.color.setHSL(0.6, 1, 0.6);\n    hemiLight.groundColor.setHSL(0.095, 1, 0.75);\n    hemiLight.position.set(0, 800, 3000);\n    this.scene.add(hemiLight);\n\n    const sunlight = new THREE.DirectionalLight(0xffffff, 0.5);\n    sunlight.position.set(0, 800, 1000);\n    sunlight.matrixWorldNeedsUpdate = true;\n    this.world.add(sunlight);\n\n    // const lights = [];\n    // lights[0] = new THREE.PointLight(0x999999, 1, 0);\n    // lights[1] = new THREE.PointLight(0x999999, 1, 0);\n    // lights[2] = new THREE.PointLight(0x999999, 0.2, 0);\n\n    // // lights[0].position.set(0, 200, 1000);\n    // lights[1].position.set(-2000, -2000, 2000);\n    // lights[2].position.set(2000, 2000, 2000);\n\n    // // // this.scene.add(lights[0]);\n    // // this.scene.add(lights[1]);\n    // this.scene.add(lights[2]);\n  },\n\n  setupHemisphereLights() {\n    // Taken from https://threejs.org/examples/webgl_lights_hemisphere.html\n    // LIGHTS\n    // HemisphereLight does not cast shadows\n    const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);\n    hemiLight.color.setHSL(0.6, 1, 0.6);\n    hemiLight.groundColor.setHSL(0.095, 1, 0.75);\n    hemiLight.position.set(0, 800, 3000);\n\n    // Used to cast shadows\n    const dirLight = new THREE.DirectionalLight(0xffffff, 1);\n    dirLight.color.setHSL(0.1, 1, 0.95);\n    dirLight.position.set(-1, 1.75, 1);\n    dirLight.position.multiplyScalar(30);\n\n    dirLight.castShadow = true;\n\n    dirLight.shadow.mapSize.width = 2048;\n    dirLight.shadow.mapSize.height = 2048;\n\n    const d = 50;\n\n    dirLight.shadow.camera.left = -d;\n    dirLight.shadow.camera.right = d;\n    dirLight.shadow.camera.top = d;\n    dirLight.shadow.camera.bottom = -d;\n    dirLight.shadow.camera.far = 3500;\n    dirLight.shadow.bias = -0.0001;\n\n\n    this.scene.add(hemiLight);\n    this.scene.add(dirLight);\n\n    this.hemiLight = hemiLight;\n    this.dirLight = dirLight;\n  },\n};\n\nwindow.Threebox = Threebox;\nmodule.exports = Threebox;\n\n\n\n\n// WEBPACK FOOTER //\n// src/Threebox.js","import THREE from '../three';\nimport * as utils from '../utils';\nimport ThreeboxConstants from '../constants';\n\nfunction CameraSync(map, camera, world) {\n  this.map = map;\n  this.camera = camera;\n  this.active = true;\n\n  this.camera.matrixAutoUpdate = false;   // We're in charge of the camera now!\n\n    // Postion and configure the world group so we can scale it appropriately when the camera zooms\n  this.world = world || new THREE.Group();\n  this.world.position.x = this.world.position.y = ThreeboxConstants.WORLD_SIZE / 2;\n  this.world.matrixAutoUpdate = false;\n\n    // Listen for move events from the map and update the Three.js camera\n  const _this = this;\n  this.map.on('move', () => { _this.updateCamera(); });\n  this.updateCamera();\n}\n\nCameraSync.prototype = {\n  updateCamera(ev) {\n    if (!this.camera) {\n      console.log('nocamera'); // eslint-disable-line\n      return;\n    }\n\n        // Build a projection matrix, paralleling the code found in Mapbox GL JS\n    const fov = 0.6435011087932844;\n    const cameraToCenterDistance = 0.5 / Math.tan(fov / 2) * this.map.transform.height;\n    const halfFov = fov / 2;\n    const groundAngle = Math.PI / 2 + this.map.transform._pitch;\n    const topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov);\n\n        // Calculate z distance of the farthest fragment that should be rendered.\n    const furthestDistance = Math.cos(Math.PI / 2 - this.map.transform._pitch) * topHalfSurfaceDistance + cameraToCenterDistance;\n\n        // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\n    const farZ = furthestDistance * 1.01;\n\n    this.camera.projectionMatrix = utils.makePerspectiveMatrix(fov, this.map.transform.width / this.map.transform.height, 1, farZ);\n\n\n    const cameraWorldMatrix = new THREE.Matrix4();\n    const cameraTranslateZ = new THREE.Matrix4().makeTranslation(0, 0, cameraToCenterDistance);\n    const cameraRotateX = new THREE.Matrix4().makeRotationX(this.map.transform._pitch);\n    const cameraRotateZ = new THREE.Matrix4().makeRotationZ(this.map.transform.angle);\n\n        // Unlike the Mapbox GL JS camera, separate camera translation and rotation out into its world matrix\n        // If this is applied directly to the projection matrix, it will work OK but break raycasting\n    cameraWorldMatrix\n            .premultiply(cameraTranslateZ)\n            .premultiply(cameraRotateX)\n            .premultiply(cameraRotateZ);\n\n    this.camera.matrixWorld.copy(cameraWorldMatrix);\n\n\n    const zoomPow = this.map.transform.scale;\n        // Handle scaling and translation of objects in the map in the world's matrix transform, not the camera\n    const scale = new THREE.Matrix4();\n    const translateCenter = new THREE.Matrix4();\n    const translateMap = new THREE.Matrix4();\n    const rotateMap = new THREE.Matrix4();\n\n    scale.makeScale(zoomPow, zoomPow, zoomPow);\n    translateCenter.makeTranslation(ThreeboxConstants.WORLD_SIZE / 2, -ThreeboxConstants.WORLD_SIZE / 2, 0);\n    translateMap.makeTranslation(-this.map.transform.x, this.map.transform.y, 0);\n    rotateMap.makeRotationZ(Math.PI);\n    this.world.matrix = new THREE.Matrix4();\n    this.world.matrix\n            .premultiply(rotateMap)\n            .premultiply(translateCenter)\n            .premultiply(scale)\n            .premultiply(translateMap);\n\n\n        // utils.prettyPrintMatrix(this.camera.projectionMatrix.elements);\n  },\n\n};\n\nmodule.exports = CameraSync;\n\n\n\n// WEBPACK FOOTER //\n// src/Camera/CameraSync.js","import THREE from '../three';\nimport valueGenerator from '../Utils/valueGenerator';\n\nfunction SymbolLayer3D(parent, options) {\n  if (options === undefined) {\n    console.error('Invalid options provided to SymbolLayer3D'); // eslint-disable-line\n    return;\n  }\n    // TODO: Better error handling here\n\n  if (options.scale === undefined) options.scale = 1.0;\n  if (options.rotation === undefined) options.rotation = 0;\n  if (options.scaleWithMapProjection === undefined) options.scaleWithMapProjection = true;\n  if (options.key === undefined || options.key === '' || (typeof options.key === 'object' && options.key.property === undefined && options.key.generator === undefined)) { // eslint-disable-line\n    options.key = {\n      generator: (val, i) => i,\n    };\n    console.warn('Using array index for SymbolLayer3D key property.'); // eslint-disable-line\n  }\n\n  this.parent = parent;\n\n  this.id = options.id;\n  this.keyGen = valueGenerator(options.key);\n  if (typeof options.source === 'string') { this.sourcePath = options.source; } else { this.source = options.source; }\n\n  this.modelDirectoryGen = valueGenerator(options.modelDirectory);\n  this.modelNameGen = valueGenerator(options.modelName);\n  this.rotationGen = valueGenerator(options.rotation);\n  this.scaleGen = valueGenerator(options.scale);\n  this.models = Object.create(null);\n  this.features = Object.create(null);\n  this.scaleWithMapProjection = options.scaleWithMapProjection;\n\n  this.loaded = false;\n\n  if (this.sourcePath) {\n        // Load source and models\n    const sourceLoader = new THREE.FileLoader();\n\n    sourceLoader.load(this.sourcePath, (data) => {\n      this.source = JSON.parse(data);\n            // TODO: Handle invalid GeoJSON\n\n      this._initialize();\n    }, () => (null), (error) => {\n      return console.error('Could not load SymbolLayer3D source file.'); // eslint-disable-line\n    });\n  } else {\n    this._initialize();\n  }\n}\n\nSymbolLayer3D.prototype = {\n  updateSourceData(source, absolute) {\n    const oldFeatures = {};\n\n    if (!source.features) {\n      console.error(\"updateSourceData expects a GeoJSON FeatureCollection with a 'features' property\"); // eslint-disable-line\n      return;\n    }\n    source.features.forEach((feature, i) => {\n      const key = this.keyGen(feature, i); // TODO: error handling\n      if (key in this.features) {\n                // Update\n        this.features[key].geojson = feature;\n        oldFeatures[key] = feature;\n      } else {\n                // Create\n        const modelDirectory = this.modelDirectoryGen(feature, i);\n        const modelName = this.modelNameGen(feature, i);\n\n                // TODO: Handle loading of new models\n        this.features[key] = {\n          geojson: feature,\n          model: modelDirectory + modelName,\n        };\n      }\n    });\n\n    this._addOrUpdateFeatures(this.features);\n\n    if (absolute) {\n      // Check for any features that are not have not been updated and remove them from the scene\n      Object.keys(this.features).forEach((key) => {\n        if (!(key in oldFeatures)) {\n          this.removeFeature(key);\n        }\n      });\n      // for (key in this.features) {\n      //   if (!(key in oldFeatures)) {\n      //     this.removeFeature(key);\n      //   }\n      // }\n    }\n\n    this.source = source;\n  },\n  removeFeature(key) {\n    this.parent.remove(this.features[key].rawObject);\n    delete this.features[key];\n  },\n  _initialize() {\n    const modelNames = [];\n\n        // Determine how to load the models\n    if (!this.modelNameGen) {\n      console.error('Invalid model name definition provided to SymbolLayer3D'); // eslint-disable-line\n      return;\n    }\n    if (!this.modelDirectoryGen) {\n      console.error('Invalid model directory definition provided to SymbolLayer3D'); // eslint-disable-line\n      return;\n    }\n\n        // Add features to a map\n    this.source.features.forEach((f, i) => {\n      const key = this.keyGen(f, i); // TODO: error handling\n      if (this.features[key] !== undefined) {\n        console.warn(`Features with duplicate key: ${key}`); // eslint-disable-line\n      }\n\n      const modelDirectory = this.modelDirectoryGen(f, i);\n      const modelName = this.modelNameGen(f, i);\n      this.features[key] = {\n        geojson: f,\n        model: modelDirectory + modelName,\n      };\n\n      modelNames.push({directory: modelDirectory, name: modelName});\n    });\n\n        // Filter out only unique models\n    modelNames.forEach((mod) => {\n      this.models[(mod.directory + mod.name)] = {\n        directory: mod.directory,\n        name: mod.name,\n        loaded: false,\n      };\n    });\n\n    // And load models asynchronously\n    let remaining = Object.keys(this.models).length;\n    console.log(`Loading ${remaining} models`, this.models); // eslint-disable-line\n    const modelComplete = (mod) => {\n      console.log('Model complete!', mod); // eslint-disable-line\n      remaining -= 1;\n      if (remaining === 0) {\n        this.loaded = true;\n        this._addOrUpdateFeatures(this.features);\n      }\n    };\n\n    Object.keys(this.models).forEach((modelKey) => {\n      // TODO: Support formats other than OBJ/MTL\n      const objLoader = new THREE.OBJLoader();\n      const materialLoader = new THREE.MTLLoader();\n\n      const loadObject = ((modelName) => {\n        return (materials) => {\n          // Closure madness!\n          if (materials) {\n            materials.preload();\n\n            Object.keys(materials.materials).forEach((matKey) => {\n              materials.materials[matKey].shininess /= 50;  // Shininess exported by Blender is way too high\n            });\n\n            objLoader.setMaterials(materials);\n          }\n          objLoader.setPath(this.models[modelName].directory);\n\n          console.log('Loading model ', modelName); // eslint-disable-line\n\n          objLoader.load(`${this.models[modelName].name}.obj`, (obj) => {\n            this.models[modelName].obj = obj;\n            this.models[modelName].isMesh = obj.isMesh;\n            this.models[modelName].loaded = true;\n\n            modelComplete(modelName);\n          }, () => (null), (error) => {\n            console.error('Could not load SymbolLayer3D model file.'); // eslint-disable-line\n          });\n        };\n      })(modelKey);\n\n      materialLoader.setPath(this.models[modelKey].directory);\n      materialLoader.load(`${this.models[modelKey].name}.mtl`, loadObject, () => (null), (error) => {\n        console.warn(`No material file found for SymbolLayer3D model ${model}`); // eslint-disable-line\n        loadObject();\n      });\n    });\n  },\n  _addOrUpdateFeatures(features) {\n    Object.keys(features).forEach((key) => {\n      const f = features[key];\n      const position = f.geojson.geometry.coordinates;\n      const scale = this.scaleGen(f.geojson);\n\n      const rotation = this.rotationGen(f.geojson);\n\n      let obj;\n      if (!f.rawObject) {\n        // Need to create a scene graph object and add it to the scene\n        if (f.model && this.models[f.model] && this.models[f.model].obj && this.models[f.model].loaded) { obj = this.models[f.model].obj.clone(); } else {\n          console.warn(`Model not loaded: ${f.model}`); // eslint-disable-line\n          obj = new THREE.Group();    // Temporary placeholder if the model doesn't exist and/or will be loaded later\n        }\n\n        f.rawObject = obj;\n\n        this.parent.addAtCoordinate(obj, position, {scaleToLatitude: this.scaleWithMapProjection, preScale: scale});\n                // this.features[key] = f;\n      } else {\n        obj = f.rawObject;\n        this.parent.moveToCoordinate(obj, position, {scaleToLatitude: this.scaleWithMapProjection, preScale: scale});\n      }\n\n      obj.rotation.copy(rotation);\n    });\n  },\n};\n\nmodule.exports = SymbolLayer3D;\n\n\n\n// WEBPACK FOOTER //\n// src/Layers/SymbolLayer3D.js","export default function valueGenerator(input) {\n    if (typeof input === 'object' && input.property !== undefined) { // Value name comes from a property in each item\n        return (f => f.properties[input.property]);\n    } else if (typeof input === 'object' && input.generator !== undefined) { // Value name generated by a function run on each item\n        return input.generator;\n    }\n    return (() => input);\n}\n\n\n\n// WEBPACK FOOTER //\n// src/Utils/valueGenerator.js","export default class RAF {\n    constructor(renderer, scene, camera) {\n        this.queue = [];\n        this.afterQueue = [];\n        this.isRunning = false;\n        this.isStepping = false;\n        this.raf = null;\n\n        const update = (timestamp) => {\n            if (this.isRunning || this.isStepping) {\n            this.isStepping = false;\n            this.raf = requestAnimationFrame(update);\n\n            this.queue.forEach((queue) => {\n                queue.fn.call(queue.scope, timestamp);\n            });\n\n            renderer.render(scene, camera);\n\n            this.afterQueue.forEach((queue) => {\n                queue.fn.call(queue.scope, timestamp);\n            });\n            }\n        };\n\n        const run = () => {\n            this.raf = requestAnimationFrame(update);\n        };\n\n        this.start = () => {\n            if (!this.isRunning) {\n            if (this.raf) {\n                cancelAnimationFrame(this.raf);\n            }\n            this.isRunning = true;\n            }\n            run();\n        };\n\n        this.step = () => {\n            if (!this.isRunning) {\n            this.isStepping = true;\n            run();\n            }\n        };\n\n        this.stop = () => {\n            this.isRunning = false;\n            if (this.raf) {\n            cancelAnimationFrame(this.raf);\n            }\n            this.raf = null;\n        };\n\n        this.onUpdate = (fn, scope) => {\n            this.queue.push({\n            fn,\n            scope,\n            });\n        };\n\n        this.onAfterUpdate = (fn, scope) => {\n            this.afterQueue.push({\n            fn,\n            scope,\n            });\n        };\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// src/utils/RAF.js","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/threebox.scss\n// module id = 8\n// module chunks = 0","import THREE from '../three';\n\nexport function prettyPrintMatrix(uglymatrix) {\n  for (let s = 0; s < 4; s += 1) {\n    const quartet = [uglymatrix[s],\n      uglymatrix[s + 4],\n      uglymatrix[s + 8],\n      uglymatrix[s + 12]];\n    console.log(quartet.map((num) => { return num.toFixed(4); })); // eslint-disable-line\n  }\n}\n\nexport function makePerspectiveMatrix(fovy, aspect, near, far) {\n  const out = new THREE.Matrix4();\n  const f = 1.0 / Math.tan(fovy / 2);\n  const nf = 1 / (near - far);\n  out.elements[0] = f / aspect;\n  out.elements[1] = 0;\n  out.elements[2] = 0;\n  out.elements[3] = 0;\n  out.elements[4] = 0;\n  out.elements[5] = f;\n  out.elements[6] = 0;\n  out.elements[7] = 0;\n  out.elements[8] = 0;\n  out.elements[9] = 0;\n  out.elements[10] = (far + near) * nf;\n  out.elements[11] = -1;\n  out.elements[12] = 0;\n  out.elements[13] = 0;\n  out.elements[14] = (2 * far * near) * nf;\n  out.elements[15] = 0;\n  return out;\n}\n\n// gimme radians\nexport function radify(deg) {\n  if (typeof deg === 'object') {\n    return deg.map((degree) => {\n      return Math.PI * 2 * degree / 360;\n    });\n  }\n\n  return Math.PI * 2 * deg / 360;\n}\n\n// gimme degrees\nexport function degreeify(rad) {\n  return 360 * rad / (Math.PI * 2);\n}\n\n\n\n// WEBPACK FOOTER //\n// src/utils/index.js"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;AC7DA;AACA;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;;;;;ACHA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAvPA;AACA;AAyPA;AACA;;;;;;;;;ACrSA;AACA;;;AAAA;AACA;AADA;AACA;AAAA;AACA;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AA1DA;AACA;AA6DA;;;;;;;;;;;;ACpFA;AACA;;;AAAA;AACA;;;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvKA;AACA;AAyKA;;;;;;;;;;;;;;;AC/NA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;ACPA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AApEA;;;;;;ACAA;;;;;;;;;;;;;;;;;;;ACEA;AAUA;AAwBA;AAWA;AACA;AAhDA;AACA;;;;;AACA;AACA;AACA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A","sourceRoot":""}