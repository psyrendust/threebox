{"version":3,"file":"flocking.js","sources":["webpack:///webpack/bootstrap 0d7800a1b9ba7c734ae7","webpack:///src/three.js","webpack:///flocking-gpgpu/index.js","webpack:///flocking-gpgpu/BirdFlocking/index.js","webpack:///./node_modules/gpucomputationrender-threejs/GPUComputationRenderer.js","webpack:///flocking-gpgpu/shaders/object-shader/index.js","webpack:///./flocking-gpgpu/shaders/object-shader/FragmentShader.glsl","webpack:///./flocking-gpgpu/shaders/object-shader/VertexShader.glsl","webpack:///flocking-gpgpu/shaders/position-shader/index.js","webpack:///./flocking-gpgpu/shaders/position-shader/FragmentShader.glsl","webpack:///flocking-gpgpu/shaders/velocity-shader/index.js","webpack:///./flocking-gpgpu/shaders/velocity-shader/FragmentShader.glsl","webpack:///flocking-gpgpu/mapboxgl.js","webpack:///flocking-gpgpu/config.js","webpack:///src/stats.js","webpack:///src/dat.gui.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0d7800a1b9ba7c734ae7","const THREE = window.THREE;\nexport default THREE;\n\n\n\n// WEBPACK FOOTER //\n// src/three.js","import Birdflocking from './BirdFlocking';\n// import OldFlocking from './OldFlocking';\nimport mapboxgl from './mapboxgl';\nimport config from './config';\nimport Stats from '../src/stats';\n\nmapboxgl.accessToken = config.accessToken;\nconst map = new mapboxgl.Map({\n  container: 'map',\n  style: 'mapbox://styles/mapbox/dark-v9',\n  center: [-122.4131, 37.7743],\n  zoom: 13,\n  pitch: 60,\n  hash: false,\n});\nmap.addControl(new mapboxgl.NavigationControl(), 'bottom-right');\n\nmap.on('load', () => {\n  // const oldFlocking = new OldFlocking(map);\n  // const threebox = oldFlocking.threebox;\n  const birdFlocking = new Birdflocking(map);\n  const threebox = birdFlocking.threebox;\n  const container = document.querySelector('body');\n  const stats = new Stats();\n  container.appendChild(stats.dom);\n\n  // oldFlocking.drive();\n  birdFlocking.init();\n  threebox.onAfterUpdate(() => {\n    stats.update();\n  });\n});\n\n\n\n\n// WEBPACK FOOTER //\n// flocking-gpgpu/index.js","/* eslint no-bitwise: 0 */\nimport THREE from '../../src/three';\nimport { GPUComputationRenderer } from 'gpucomputationrender-threejs';\nimport dat from '../../src/dat.gui';\n\nconst birdShaders = require('../shaders/object-shader');\nconst positionShaders = require('../shaders/position-shader');\nconst velocityShaders = require('../shaders/velocity-shader');\n\nlet hash = document.location.hash.substr(1);\nif (hash) hash = parseInt(hash, 0);\n\n/* TEXTURE WIDTH FOR SIMULATION */\nconst WIDTH = hash || 32;\n\nconst BIRDS = WIDTH * WIDTH;\n\n// Custom Geometry - using 3 triangles each. No UVs, no normals currently.\nTHREE.BirdGeometry = function BirdGeometry() {\n  const triangles = BIRDS * 3;\n  const points = triangles * 3;\n\n  THREE.BufferGeometry.call(this);\n\n  const vertices = new THREE.BufferAttribute(new Float32Array(points * 3), 3);\n  const birdColors = new THREE.BufferAttribute(new Float32Array(points * 3), 3);\n  const references = new THREE.BufferAttribute(new Float32Array(points * 2), 2);\n  const birdVertex = new THREE.BufferAttribute(new Float32Array(points), 1);\n\n  this.addAttribute('position', vertices);\n  this.addAttribute('birdColor', birdColors);\n  this.addAttribute('reference', references);\n  this.addAttribute('birdVertex', birdVertex);\n\n  // this.addAttribute( 'normal', new Float32Array( points * 3 ), 3 );\n\n\n  let vert = 0;\n\n  function vertsPush(...args) {\n    for (let i = 0; i < arguments.length; i += 1) {\n      vertices.array[vert] = args[i];\n      vert += 1;\n    }\n  }\n\n  const wingsSpan = 20;\n\n  for (let f = 0; f < BIRDS; f += 1) {\n    // Body\n    vertsPush(\n      0, -0, -20,\n      0, 4, -20,\n      0, 0, 30,\n    );\n\n    // Left Wing\n    vertsPush(\n      0, 0, -15,\n      -wingsSpan, 0, 0,\n      0, 0, 15,\n    );\n\n    // Right Wing\n    vertsPush(\n      0, 0, 15,\n      wingsSpan, 0, 0,\n      0, 0, -15,\n    );\n  }\n\n  for (let vtx = 0; vtx < triangles * 3; vtx += 1) {\n    const i = ~~(vtx / 3);\n    const x = (i % WIDTH) / WIDTH;\n    const y = ~~(i / WIDTH) / WIDTH;\n\n    const c = new THREE.Color(\n      0x444444 +\n      ~~(vtx / 9) / BIRDS * 0x666666,\n    );\n\n    birdColors.array[vtx * 3 + 0] = c.r;\n    birdColors.array[vtx * 3 + 1] = c.g;\n    birdColors.array[vtx * 3 + 2] = c.b;\n\n    references.array[vtx * 2] = x;\n    references.array[vtx * 2 + 1] = y;\n\n    birdVertex.array[vtx] = vtx % 9;\n  }\n\n  this.scale(0.2, 0.2, 0.2);\n};\n\nTHREE.BirdGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\n\nlet threebox;\nlet stats;\nlet scene;\nlet renderer;\nlet i;\nlet mouseX = 0;\nlet mouseY = 0;\n\nconst windowHalfX = window.innerWidth / 2;\nconst windowHalfY = window.innerHeight / 2;\n\nconst BOUNDS = 800;\nconst BOUNDS_HALF = BOUNDS / 2;\n\ndocument.getElementById('cars').innerText = BIRDS;\n\nfunction change(val) {\n  location.hash = val;\n  location.reload();\n  return false;\n}\n\nconst options = document.createDocumentFragment();\nfor (i = 1; i < 7; i += 1) {\n  const j = Math.pow(2, i); // eslint-disable-line\n  const link = document.createElement('a');\n  link.textContent = `${j * j}`;\n  link.href = '#';\n  link.onclick = () => {\n    return change(j);\n  };\n  options.appendChild(link);\n}\ndocument.getElementById('options').appendChild(options);\n\nlet last = performance.now();\n\nlet gpuCompute;\nlet velocityVariable;\nlet positionVariable;\nlet positionUniforms;\nlet velocityUniforms;\nlet birdUniforms;\n\nfunction fillPositionTexture(texture) {\n  const theArray = texture.image.data;\n\n  for (let k = 0, kl = theArray.length; k < kl; k += 4) {\n    const x = Math.random() * BOUNDS - BOUNDS_HALF;\n    const y = Math.random() * BOUNDS - BOUNDS_HALF;\n    const z = Math.random() * BOUNDS - BOUNDS_HALF;\n\n    theArray[k + 0] = x;\n    theArray[k + 1] = y;\n    theArray[k + 2] = z;\n    theArray[k + 3] = 1;\n  }\n}\n\nfunction fillVelocityTexture(texture) {\n  const theArray = texture.image.data;\n\n  for (let k = 0, kl = theArray.length; k < kl; k += 4) {\n    const x = Math.random() - 0.5;\n    const y = Math.random() - 0.5;\n    const z = Math.random() - 0.5;\n\n    theArray[k + 0] = x * 10;\n    theArray[k + 1] = y * 10;\n    theArray[k + 2] = z * 10;\n    theArray[k + 3] = 1;\n  }\n}\n\nfunction initComputeRenderer() {\n  gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);\n\n  const dtPosition = gpuCompute.createTexture();\n  const dtVelocity = gpuCompute.createTexture();\n  fillPositionTexture(dtPosition);\n  fillVelocityTexture(dtVelocity);\n\n  velocityVariable = gpuCompute.addVariable('textureVelocity', velocityShaders.fragmentShader, dtVelocity);\n  positionVariable = gpuCompute.addVariable('texturePosition', positionShaders.fragmentShader, dtPosition);\n\n  gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);\n  gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);\n\n  positionUniforms = positionVariable.material.uniforms;\n  velocityUniforms = velocityVariable.material.uniforms;\n\n  positionUniforms.time = {value: 0.0};\n  positionUniforms.delta = {value: 0.0};\n  velocityUniforms.time = {value: 1.0};\n  velocityUniforms.delta = {value: 0.0};\n  velocityUniforms.testing = {value: 1.0};\n  velocityUniforms.seperationDistance = {value: 1.0};\n  velocityUniforms.alignmentDistance = {value: 1.0};\n  velocityUniforms.cohesionDistance = {value: 1.0};\n  velocityUniforms.freedomFactor = {value: 1.0};\n  velocityUniforms.predator = {value: new THREE.Vector3()};\n  velocityVariable.material.defines.BOUNDS = BOUNDS.toFixed(2);\n\n  velocityVariable.wrapS = THREE.RepeatWrapping;\n  velocityVariable.wrapT = THREE.RepeatWrapping;\n  positionVariable.wrapS = THREE.RepeatWrapping;\n  positionVariable.wrapT = THREE.RepeatWrapping;\n\n  const error = gpuCompute.init();\n  if (error !== null) {\n    console.error(error); // eslint-disable-line\n  }\n}\n\nfunction initBirds() {\n  const geometry = new THREE.BirdGeometry();\n\n  // For Vertex and Fragment\n  birdUniforms = {\n    color: {value: new THREE.Color(0xff2200)},\n    texturePosition: {value: null},\n    textureVelocity: {value: null},\n    time: {value: 1.0},\n    delta: {value: 0.0},\n  };\n\n  // ShaderMaterial\n  const material = new THREE.ShaderMaterial({\n    uniforms: birdUniforms,\n    vertexShader: birdShaders.vertexShader,\n    fragmentShader: birdShaders.fragmentShader,\n    side: THREE.DoubleSide,\n  });\n\n  const birdMesh = new THREE.Mesh(geometry, material);\n  birdMesh.rotation.y = Math.PI / 2;\n  birdMesh.matrixAutoUpdate = false;\n  birdMesh.updateMatrix();\n\n  scene.add(birdMesh);\n}\n\n\n// function onWindowResize() {\n//   windowHalfX = window.innerWidth / 2;\n//   windowHalfY = window.innerHeight / 2;\n\n//   camera.aspect = window.innerWidth / window.innerHeight;\n//   camera.updateProjectionMatrix();\n\n//   renderer.setSize(window.innerWidth, window.innerHeight);\n// }\n\nfunction onDocumentMouseMove(event) {\n  mouseX = event.clientX - windowHalfX;\n  mouseY = event.clientY - windowHalfY;\n}\n\nfunction onDocumentTouchStart(event) {\n  if (event.touches.length === 1) {\n    event.preventDefault();\n\n    mouseX = event.touches[0].pageX - windowHalfX;\n    mouseY = event.touches[0].pageY - windowHalfY;\n  }\n}\n\nfunction onDocumentTouchMove(event) {\n  if (event.touches.length === 1) {\n    event.preventDefault();\n\n    mouseX = event.touches[0].pageX - windowHalfX;\n    mouseY = event.touches[0].pageY - windowHalfY;\n  }\n}\n\nfunction render() {\n  const now = performance.now();\n  let delta = (now - last) / 1000;\n\n  if (delta > 1) delta = 1; // safety cap on large deltas\n  last = now;\n\n  positionUniforms.time.value = now;\n  positionUniforms.delta.value = delta;\n  velocityUniforms.time.value = now;\n  velocityUniforms.delta.value = delta;\n  birdUniforms.time.value = now;\n  birdUniforms.delta.value = delta;\n\n  velocityUniforms.predator.value.set(0.5 * mouseX / windowHalfX, -0.5 * mouseY / windowHalfY, 0);\n\n  mouseX = 10000;\n  mouseY = 10000;\n\n  gpuCompute.compute();\n\n  birdUniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;\n  birdUniforms.textureVelocity.value = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;\n\n  // renderer.render(scene, camera);\n}\n\n\nfunction init() {\n  // container = document.createElement('div');\n  // document.body.appendChild(container);\n\n  // camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);\n  // camera.position.z = 350;\n\n  // scene = new THREE.Scene();\n  // scene.background = new THREE.Color(0xffffff);\n  // scene.fog = new THREE.Fog(0xffffff, 100, 1000);\n\n  // renderer = new THREE.WebGLRenderer();\n  // renderer.setPixelRatio(window.devicePixelRatio);\n  // renderer.setSize(window.innerWidth, window.innerHeight);\n  // container.appendChild(renderer.domElement);\n  scene = threebox.world;\n  renderer = threebox.renderer;\n\n  initComputeRenderer();\n\n  document.addEventListener('mousemove', onDocumentMouseMove, false);\n  document.addEventListener('touchstart', onDocumentTouchStart, false);\n  document.addEventListener('touchmove', onDocumentTouchMove, false);\n\n  //\n\n  // window.addEventListener('resize', onWindowResize, false);\n\n\n  const gui = new dat.GUI();\n\n  const effectController = {\n    seperation: 20.0,\n    alignment: 20.0,\n    cohesion: 20.0,\n    freedom: 0.75,\n  };\n\n  const valuesChanger = () => {\n    velocityUniforms.seperationDistance.value = effectController.seperation;\n    velocityUniforms.alignmentDistance.value = effectController.alignment;\n    velocityUniforms.cohesionDistance.value = effectController.cohesion;\n    velocityUniforms.freedomFactor.value = effectController.freedom;\n  };\n\n  valuesChanger();\n\n  gui.add(effectController, 'seperation', 0.0, 100.0, 1.0).onChange(valuesChanger);\n  gui.add(effectController, 'alignment', 0.0, 100, 0.001).onChange(valuesChanger);\n  gui.add(effectController, 'cohesion', 0.0, 100, 0.025).onChange(valuesChanger);\n  gui.close();\n\n  initBirds();\n\n  threebox.onRender(() => {\n    render();\n  });\n}\n\n\nfunction BirdFlocking(map) {\n  threebox = new window.Threebox(map);\n  threebox.setupDefaultLights();\n  this.threebox = threebox;\n  this.init = () => {\n    init();\n  };\n}\n\nmodule.exports = BirdFlocking;\n\n\n\n// WEBPACK FOOTER //\n// flocking-gpgpu/BirdFlocking/index.js","/**\n * @author yomboprime https://github.com/yomboprime\n *\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n  */\n\nimport {\n\tScene,\n\tCamera,\n\tMesh,\n\tPlaneBufferGeometry,\n\tShaderMaterial,\n\tClampToEdgeWrapping,\n\tNearestFilter,\n\tWebGLRenderTarget,\n\tHalfFloatType,\n\tFloatType,\n\tDataTexture,\n\tRGBAFormat,\n\tminFilter,\n\tmagFilter\n  } from 'three';\n\nexport function GPUComputationRenderer( sizeX, sizeY, renderer ) {\n\n\tthis.variables = [];\n\n\tthis.currentTextureIndex = 0;\n\n\tlet scene = new Scene();\n\tlet camera = new Camera();\n\tcamera.position.z = 1;\n\n\tlet passThruUniforms = {\n\t\ttexture: { value: null }\n\t};\n\n\tlet passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\tlet mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), passThruShader );\n\tscene.add( mesh );\n\n\tthis.addVariable = function( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\tlet material = this.createShaderMaterial( computeFragmentShader );\n\n\t\tlet variable = {\n\t\t\tname: variableName,\n\t\t\tinitialValueTexture,\n\t\t\tmaterial,\n\t\t\tdependencies: null,\n\t\t\trenderTargets: [],\n\t\t\twrapS: null,\n\t\t\twrapT: null,\n\t\t\tminFilter: NearestFilter,\n\t\t\tmagFilter: NearestFilter\n\t\t};\n\n\t\tthis.variables.push( variable );\n\n\t\treturn variable;\n\n\t};\n\n\tthis.setVariableDependencies = function( variable, dependencies ) {\n\n\t\tvariable.dependencies = dependencies;\n\n\t};\n\n\tthis.init = function() {\n\n\t\tif ( ! renderer.extensions.get( \"OES_texture_float\" ) ) {\n\n\t\t\treturn \"No OES_texture_float support for float textures.\";\n\n\t\t}\n\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\treturn \"No support for vertex shader textures.\";\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.variables.length; i++ ) {\n\n\t\t\tlet variable = this.variables[ i ];\n\n\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\tlet material = variable.material;\n\t\t\tlet uniforms = material.uniforms;\n\t\t\tif ( variable.dependencies !== null ) {\n\t\t\t\tfor ( let d = 0; d < variable.dependencies.length; d++ ) {\n\n\t\t\t\t\tlet depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\tlet found = false;\n\t\t\t\t\t\tfor ( let j = 0; j < this.variables.length; j++ ) {\n\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ! found ) {\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\treturn null;\n\n\t};\n\n\tthis.compute = function() {\n\n\t\tlet currentTextureIndex = this.currentTextureIndex;\n\t\tlet nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\tfor ( let i = 0, il = this.variables.length; i < il; i++ ) {\n\n\t\t\tlet variable = this.variables[ i ];\n\n\t\t\t// Sets texture dependencies uniforms\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tlet uniforms = variable.material.uniforms;\n\t\t\t\tfor ( let d = 0, dl = variable.dependencies.length; d < dl; d++ ) {\n\n\t\t\t\t\tlet depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Performs the computation for this variable\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t}\n\n\t\tthis.currentTextureIndex = nextTextureIndex;\n\t};\n\n\tthis.getCurrentRenderTarget = function( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t};\n\n\tthis.getAlternateRenderTarget = function( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t};\n\n\tfunction addResolutionDefine( materialShader ) {\n\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\n\n\t};\n\n\tthis.addResolutionDefine = addResolutionDefine;\n\n\t// The following functions can be used to compute things manually\n\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\tuniforms = uniforms || {};\n\n\t\tlet material = new ShaderMaterial( {\n\t\t\tuniforms,\n\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\tfragmentShader: computeFragmentShader\n\t\t} );\n\n\t\taddResolutionDefine( material );\n\n\t\treturn material;\n\t};\n\n\tthis.createShaderMaterial = createShaderMaterial;\n\n\tthis.createRenderTarget = function( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\twrapS = wrapS || ClampToEdgeWrapping;\n\t\twrapT = wrapT || ClampToEdgeWrapping;\n\n\t\tminFilter = minFilter || NearestFilter;\n\t\tmagFilter = magFilter || NearestFilter;\n\n\t\tlet renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\twrapS,\n\t\t\twrapT,\n\t\t\tminFilter,\n\t\t\tmagFilter,\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) ? HalfFloatType : FloatType,\n\t\t\tstencilBuffer: false\n\t\t} );\n\n\t\treturn renderTarget;\n\n\t};\n\n\tthis.createTexture = function( sizeXTexture, sizeYTexture ) {\n\n\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\tlet a = new Float32Array( sizeXTexture * sizeYTexture * 4 );\n\t\tlet texture = new DataTexture( a, sizeX, sizeY, RGBAFormat, FloatType );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t};\n\n\tthis.renderTexture = function( input, output ) {\n\n\t\t// Takes a texture, and render out in rendertarget\n\t\t// input = Texture\n\t\t// output = RenderTarget\n\n\t\tpassThruUniforms.texture.value = input;\n\n\t\tthis.doRenderTarget( passThruShader, output);\n\n\t\tpassThruUniforms.texture.value = null;\n\n\t};\n\n\tthis.doRenderTarget = function( material, output ) {\n\n\t\tmesh.material = material;\n\t\trenderer.render( scene, camera, output );\n\t\tmesh.material = passThruShader;\n\n\t};\n\n\t// Shaders\n\n\tfunction getPassThroughVertexShader() {\n\t\treturn\t`void main(){\n\t\t\t\t\tgl_Position = vec4( position, 1.0 );\n\t\t\t\t}`;\n\t};\n\n\tfunction getPassThroughFragmentShader() {\n\t\treturn\t`uniform sampler2D texture;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\t\t\t\t\tgl_FragColor = texture2D( texture, uv );\n\t\t\t\t}`;\n\t};\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/gpucomputationrender-threejs/GPUComputationRenderer.js\n// module id = 3\n// module chunks = 0","import fragment from './FragmentShader.glsl';\nimport vertex from './VertexShader.glsl';\n\nconst shaders = {\n    fragment,\n    vertex,\n};\n\nexport default shaders;\n\n\n\n// WEBPACK FOOTER //\n// flocking-gpgpu/shaders/object-shader/index.js","module.exports = \"varying vec4 vColor;\\nvarying float z;\\n\\nuniform vec3 color;\\n\\nvoid main() {\\n  // Fake colors for now\\n  float z2 = 0.2 + ( 1000. - z ) / 1000. * vColor.x;\\n  gl_FragColor = vec4( z2, z2, z2, 1. );\\n\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flocking-gpgpu/shaders/object-shader/FragmentShader.glsl\n// module id = 6\n// module chunks = 0","module.exports = \"attribute vec2 reference;\\nattribute float birdVertex;\\n\\nattribute vec3 birdColor;\\n\\nuniform sampler2D texturePosition;\\nuniform sampler2D textureVelocity;\\n\\nvarying vec4 vColor;\\nvarying float z;\\n\\nuniform float time;\\n\\nvoid main() {\\n\\n  vec4 tmpPos = texture2D( texturePosition, reference );\\n  vec3 pos = tmpPos.xyz;\\n  vec3 velocity = normalize(texture2D( textureVelocity, reference ).xyz);\\n\\n  vec3 newPosition = position;\\n\\n  if ( birdVertex == 4.0 || birdVertex == 7.0 ) {\\n    // flap wings\\n    newPosition.y = sin( tmpPos.w ) * 5.;\\n  }\\n\\n  newPosition = mat3( modelMatrix ) * newPosition;\\n\\n\\n  velocity.z *= -1.;\\n  float xz = length( velocity.xz );\\n  float xyz = 1.;\\n  float x = sqrt( 1. - velocity.y * velocity.y );\\n\\n  float cosry = velocity.x / xz;\\n  float sinry = velocity.z / xz;\\n\\n  float cosrz = x / xyz;\\n  float sinrz = velocity.y / xyz;\\n\\n  mat3 maty =  mat3(\\n    cosry, 0, -sinry,\\n    0    , 1, 0     ,\\n    sinry, 0, cosry\\n\\n  );\\n\\n  mat3 matz =  mat3(\\n    cosrz , sinrz, 0,\\n    -sinrz, cosrz, 0,\\n    0     , 0    , 1\\n  );\\n\\n  newPosition =  maty * matz * newPosition;\\n  newPosition += pos;\\n\\n  z = newPosition.z;\\n\\n  vColor = vec4( birdColor, 1.0 );\\n  gl_Position = projectionMatrix *  viewMatrix  * vec4( newPosition, 1.0 );\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flocking-gpgpu/shaders/object-shader/VertexShader.glsl\n// module id = 7\n// module chunks = 0","import fragment from './FragmentShader.glsl';\n\nconst shaders = {\n    fragment,\n};\n\nexport default shaders;\n\n\n\n// WEBPACK FOOTER //\n// flocking-gpgpu/shaders/position-shader/index.js","module.exports = \"uniform float time;\\nuniform float delta;\\n\\nvoid main()\\t{\\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\\n  vec4 tmpPos = texture2D( texturePosition, uv );\\n  vec3 position = tmpPos.xyz;\\n  vec3 velocity = texture2D( textureVelocity, uv ).xyz;\\n\\n  float phase = tmpPos.w;\\n\\n  phase = mod( ( phase + delta +\\n    length( velocity.xz ) * delta * 3. +\\n    max( velocity.y, 0.0 ) * delta * 6. ), 62.83 );\\n\\n  gl_FragColor = vec4( position + velocity * delta * 15. , phase );\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flocking-gpgpu/shaders/position-shader/FragmentShader.glsl\n// module id = 9\n// module chunks = 0","import fragment from './FragmentShader.glsl';\n\nconst shaders = {\n    fragment,\n};\n\nexport default shaders;\n\n\n\n// WEBPACK FOOTER //\n// flocking-gpgpu/shaders/velocity-shader/index.js","module.exports = \"uniform float time;\\nuniform float testing;\\nuniform float delta; // about 0.016\\nuniform float seperationDistance; // 20\\nuniform float alignmentDistance; // 40\\nuniform float cohesionDistance; //\\nuniform float freedomFactor;\\nuniform vec3 predator;\\n\\nconst float width = resolution.x;\\nconst float height = resolution.y;\\n\\nconst float PI = 3.141592653589793;\\nconst float PI_2 = PI * 2.0;\\n// const float VISION = PI * 0.55;\\n\\nfloat zoneRadius = 40.0;\\nfloat zoneRadiusSquared = 1600.0;\\n\\nfloat separationThresh = 0.45;\\nfloat alignmentThresh = 0.65;\\n\\nconst float UPPER_BOUNDS = BOUNDS;\\nconst float LOWER_BOUNDS = -UPPER_BOUNDS;\\n\\nconst float SPEED_LIMIT = 9.0;\\n\\nfloat rand(vec2 co){\\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\nvoid main() {\\n\\n  zoneRadius = seperationDistance + alignmentDistance + cohesionDistance;\\n  separationThresh = seperationDistance / zoneRadius;\\n  alignmentThresh = ( seperationDistance + alignmentDistance ) / zoneRadius;\\n  zoneRadiusSquared = zoneRadius * zoneRadius;\\n\\n\\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\\n  vec3 birdPosition, birdVelocity;\\n\\n  vec3 selfPosition = texture2D( texturePosition, uv ).xyz;\\n  vec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;\\n\\n  float dist;\\n  vec3 dir; // direction\\n  float distSquared;\\n\\n  float seperationSquared = seperationDistance * seperationDistance;\\n  float cohesionSquared = cohesionDistance * cohesionDistance;\\n\\n  float f;\\n  float percent;\\n\\n  vec3 velocity = selfVelocity;\\n\\n  float limit = SPEED_LIMIT;\\n\\n  dir = predator * UPPER_BOUNDS - selfPosition;\\n  dir.z = 0.;\\n  // dir.z *= 0.6;\\n  dist = length( dir );\\n  distSquared = dist * dist;\\n\\n  float preyRadius = 150.0;\\n  float preyRadiusSq = preyRadius * preyRadius;\\n\\n\\n  // move birds away from predator\\n  if (dist < preyRadius) {\\n\\n    f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;\\n    velocity += normalize( dir ) * f;\\n    limit += 5.0;\\n  }\\n\\n\\n  // if (testing == 0.0) {}\\n  // if ( rand( uv + time ) < freedomFactor ) {}\\n\\n\\n  // Attract flocks to the center\\n  vec3 central = vec3( 0., 0., 0. );\\n  dir = selfPosition - central;\\n  dist = length( dir );\\n\\n  dir.y *= 2.5;\\n  velocity -= normalize( dir ) * delta * 5.;\\n\\n  for (float y=0.0;y<height;y++) {\\n    for (float x=0.0;x<width;x++) {\\n\\n      vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;\\n      birdPosition = texture2D( texturePosition, ref ).xyz;\\n\\n      dir = birdPosition - selfPosition;\\n      dist = length(dir);\\n\\n      if (dist < 0.0001) continue;\\n\\n      distSquared = dist * dist;\\n\\n      if (distSquared > zoneRadiusSquared ) continue;\\n\\n      percent = distSquared / zoneRadiusSquared;\\n\\n      if ( percent < separationThresh ) { // low\\n\\n        // Separation - Move apart for comfort\\n        f = (separationThresh / percent - 1.0) * delta;\\n        velocity -= normalize(dir) * f;\\n\\n      } else if ( percent < alignmentThresh ) { // high\\n\\n        // Alignment - fly the same direction\\n        float threshDelta = alignmentThresh - separationThresh;\\n        float adjustedPercent = ( percent - separationThresh ) / threshDelta;\\n\\n        birdVelocity = texture2D( textureVelocity, ref ).xyz;\\n\\n        f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;\\n        velocity += normalize(birdVelocity) * f;\\n\\n      } else {\\n\\n        // Attraction / Cohesion - move closer\\n        float threshDelta = 1.0 - alignmentThresh;\\n        float adjustedPercent = ( percent - alignmentThresh ) / threshDelta;\\n\\n        f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;\\n\\n        velocity += normalize(dir) * f;\\n\\n      }\\n\\n    }\\n\\n  }\\n\\n  // this make tends to fly around than down or up\\n  // if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);\\n\\n  // Speed Limits\\n  if ( length( velocity ) > limit ) {\\n    velocity = normalize( velocity ) * limit;\\n  }\\n\\n  gl_FragColor = vec4( velocity, 1.0 );\\n\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flocking-gpgpu/shaders/velocity-shader/FragmentShader.glsl\n// module id = 11\n// module chunks = 0","const mapboxgl = window.mapboxgl;\nexport default mapboxgl;\n\n\n\n// WEBPACK FOOTER //\n// flocking-gpgpu/mapboxgl.js","const config = {\n  accessToken: 'pk.eyJ1IjoicHN5cmVuZHVzdCIsImEiOiJjajVsZ3RtMXcyZ2Z0MndsbTM2c2VzZTdnIn0.4SXh1jwWtkfJURT7V8kN4w',\n};\n\nexport default config;\n\n\n\n// WEBPACK FOOTER //\n// flocking-gpgpu/config.js","const Stats = window.Stats;\nexport default Stats;\n\n\n\n// WEBPACK FOOTER //\n// src/stats.js","const dat = window.dat;\nexport default dat;\n\n\n\n// WEBPACK FOOTER //\n// src/dat.gui.js"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;AC7DA;AACA;;;;;;;;;ACDA;AACA;;;AACA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;;;AACA;AALA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9BA;AACA;;;AAAA;AACA;AAAA;AACA;;;;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AARA;AAAA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjXA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrXA;AACA;;;AAAA;AACA;;;;;AACA;AACA;AACA;AAFA;AACA;AAIA;;;;;;ACRA;;;;;;ACAA;;;;;;;;;;;;;ACAA;AACA;;;;;AACA;AACA;AADA;AACA;AAGA;;;;;;ACNA;;;;;;;;;;;;;ACAA;AACA;;;;;AACA;AACA;AADA;AACA;AAGA;;;;;;ACNA;;;;;;;;;;;;ACAA;AACA;;;;;;;;;;;;ACDA;AACA;AADA;AACA;AAGA;;;;;;;;;;;;ACJA;AACA;;;;;;;;;;;;ACDA;AACA;;;A","sourceRoot":""}